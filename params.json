{"name":"Stm32f030f4-projects","tagline":"Well, I just experiment with my stm32f030f4. Here I'll try to write tutorials","body":"### Strucutre\r\nUnder each directory is a seperate Project. All the Projects are based upon [my Template](http://dakesew.github.io/stm32f0xx_stm32cube_stripped/).\r\n### Blink Led\r\nConnect an Led between PA4 and GND\r\nLook at the main function (I’ve removed the comments)\r\n\r\n`int main(void)`\r\n`{`\r\n`  HAL_Init();`\r\n`  SystemClock_Config();`\r\n`  __GPIOA_CLK_ENABLE();`\r\n`  GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;`\r\n`  GPIO_InitStruct.Pull  = GPIO_PULLUP;`\r\n`  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;`\r\n`  GPIO_InitStruct.Pin = GPIO_PIN_4;`\r\n`  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);`\r\n`  while (1){`\r\n`    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_4);`\r\n`    HAL_Delay(1000);`\r\n`  }`\r\n`}`\r\n\r\nFirst we call HAL_Init(). That does a bunch of low-level initialisation and sets the Systick timer as a 1ms timebase (The Systick timer is included in every Cortex core  and was included so that RTOSes don’t have to be specialised to a micro, because they need to use another Timer). The SystemClock_Config call doesn’t do anything, its just included if you want to change the clock settings at the start of the program.\r\n\r\nThe we call __GPIOA_CLK_ENABLE(). This effectively activates the GPIOA peripheral, so it can be used.\r\n\r\nThe next thing we do is populate GPIO_InitStruct. We’ve already defined that before main. There are multiple values:\r\n\r\n* Mode: You define the Mode here. There are several options:\r\n  * GPIO_MODE_INPUT: Input Floating Mode\r\n  * GPIO_MODE_OUTPUT_PP:Output Push Pull Mode\r\n  * GPIO_MODE_OUTPUT_OD:Output Open Drain Mode\r\n  * GPIO_MODE_AF_PP: Alternate Function Push Pull Mode\r\n  * GPIO_MODE_AF_OD: Alternate Function Open Drain Mode\r\n  * GPIO_MODE_ANALOG: Analog Mode\r\n  * GPIO_MODE_IT_RISING: External Interrupt Mode with Rising edge trigger detection\r\n  * GPIO_MODE_IT_FALLING: External Interrupt Mode with Falling edge trigger detection\r\n  * GPIO_MODE_IT_RISING_FALLING: External Interrupt Mode with Rising/Falling edge trigger detection\r\n  * If you use Alternate Function, you’re giving the IO pin to other peripherals like the USART\r\n  * If you use Analog Mode, you can use the ADC or DAC with this pin\r\n  * There are some more Options (usually not useful). If you want to know them, read the Description of the HAL Drivers where I got these options from\r\n* Pull: Here you can define if it has a pull-up/pull-down resistor activated. Does affect your pin, if you set it to be an Output\r\n  * GPIO_NOPULL: No Pull-up or Pull-down activation\r\n  * GPIO_PULLUP: Pull-up activation\r\n  * GPIO_PULLDOWN: Pull-down activation\r\n* Speed: Here you can say how fast yourGPIO Pin should be able to change. If you don’t have a specific requirement, just leave it at high\r\n  * LOW\r\n  * MEDIUM\r\n  * HIGH\r\n*Pin: Here you can define which pins that should be valid for. It can go from 0 to 15. You can change multiple pins at once: GPIO_PIN_0 | GPIO_PIN_1\r\n\r\nThen we have the HAL_GPIO_Init(GPIOA, &GPIO_InitStruct) line. Here we give GPIO_InitStruct to the function, that does all the work and say which GPIO Port that should be valid for.\r\n\r\nAfter that we have a loop that toggles PA4 with HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_4) and then waits for 1000ms with HAL_Delay(1000).  Remember that Systick timer that I explained above? That comes into play here. It basically causes an interrupt every millisecond, that increments a variable uwTick. The delay function uses this tick, so be carefull when using it in an interrupt or when you have interrupts disabled.\r\n###Led with Button\r\n\r\n\r\nSo, lets assume we need to have inputs (crazy, right?).  Get the programm from “Led with Button” on your micro. Connect a button between PA3 and ground and an LED between PA3 and GND. Now try pressing the button. The unbelivable happendend. The LED light up ! Who’d have thougt ?</sarcasm>\r\n\r\nSo open the ./Src/main.c. You’ll find that alot is similar to the LED blinke example:\r\n`int main(void)`\r\n`{`\r\n  `HAL_Init();`\r\n  `SystemClock_Config();`\r\n  `__GPIOA_CLK_ENABLE();`\r\n  `GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;`\r\n  `GPIO_InitStruct.Pull  = GPIO_PULLUP;`\r\n  `GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;`\r\n  `GPIO_InitStruct.Pin = GPIO_PIN_4;`\r\n  `HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);`\r\n  `GPIO_InitStruct.Mode  = GPIO_MODE_INPUT;`\r\n  `GPIO_InitStruct.Pull  = GPIO_PULLUP;`\r\n  `GPIO_InitStruct.Pin = GPIO_PIN_3;`\r\n  `HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);`\r\n  `while (1){`\r\n    `if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_3) == GPIO_PIN_RESET){`\r\n      `HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,GPIO_PIN_SET);`\r\n    `}else{`\r\n      `HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,GPIO_PIN_RESET);`\r\n    `}`\r\n  `}`\r\n`}`\r\n\r\nSo, we call HAL_Init, get PA4 configured and then we just rewrite the values of the GPIO_InitStruct, so that it’s an input and it applies to PA3. Then we read PA3 and if the Pin is grounded (button is pressed), we set the PA4 bit, so LED lights up. If PA3 is high (through the Pull-up resistor), we disable the LED.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}